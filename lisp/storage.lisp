(in-package :hermes.storage)

(defconstant +fs-from-start+ #.$fsFromStart)
(defconstant +fs-from-leof+ #.$fsFromLEOF)
(defconstant +eof-err+ #.$eofErr)

(defparameter +max-nodes+ 10)
(defparameter +max-nodes-minus-one+ 9)
(defparameter +max-message-forums+ 20)
(defparameter +max-conferences-per-forum+ 50)
(defparameter +max-directory-count+ 64)
(defparameter +max-restrictions+ 26)

(defparameter *pascal-record-layouts* (make-hash-table :test #'equal))

(defparameter *legacy-caches* (make-hash-table :test #'equal))

(defun permission-code (permission)
  (ecase permission
    (:fsRdPerm #.$fsRdPerm)
    (:fsRdWrPerm #.$fsRdWrPerm)
    (:fsRdWrShPerm #.$fsRdWrShPerm)))

(defun register-layout (name layout)
  (setf (gethash name *pascal-record-layouts*) layout))

(defun pascal-layout (thing)
  (etypecase thing
    (symbol (or (gethash thing *pascal-record-layouts*)
                (error "No Pascal layout registered for ~S." thing)))
    (standard-object (pascal-layout (class-name (class-of thing))))
    (class (pascal-layout (class-name thing)))))

(defun accessor-name (class slot)
  (let* ((class-name (symbol-name class))
         (slot-name (symbol-name slot)))
    (intern (format nil "~A-~A" class-name slot-name) (symbol-package class))))

(defun slot-default-for-type (type)
  (etypecase type
    ((or (eql :int8) (eql :uint8) (eql :int16) (eql :uint16) (eql :int32) (eql :uint32)) 0)
    ((eql :boolean) nil)
    ((eql :char) #\Null)
    ((eql :byte) 0)
    ((eql :real) 0.0d0)
    ((cons) (case (car type)
              (:pascal-string "")
              (:array (make-array (second type) :initial-element (slot-default-for-type (third type))))
              (:matrix (let* ((rows (second type))
                              (cols (third type))
                              (subtype (fourth type)))
                         (let ((matrix (make-array rows)))
                           (dotimes (row rows matrix)
                             (setf (aref matrix row)
                                   (make-array cols :initial-element (slot-default-for-type subtype)))))))
              (:byte-array (make-array (second type) :element-type '(unsigned-byte 8) :initial-element 0))
              (:boolean-array (make-array (second type) :initial-element nil))
              (:int16-array (make-array (second type) :initial-element 0))
              (:int32-array (make-array (second type) :initial-element 0))
              (:struct (let* ((name (second type))
                               (layout (pascal-layout name))
                               (size (reduce #'+ (mapcar #'pascal-field-size layout)))
                               (buffer (make-array size :element-type '(unsigned-byte 8)))
                               (class (ignore-errors (find-class name nil))))
                         (if class
                             (deserialize-record name buffer)
                             (deserialize-struct layout buffer 0))))
              (:reserved (make-array (second type) :element-type '(unsigned-byte 8) :initial-element 0))
              (t (error "Unsupported compound type ~S." type))))))

(defun pascal-field-size (field)
  (etypecase field
    (symbol (pascal-type-size field))
    (cons (case (car field)
            (:field (pascal-type-size (third field)))
            (:skip (second field))
            (:pascal-string (+ 1 (second field)))
            (:array (* (second field) (pascal-type-size (third field))))
            (:matrix (* (second field) (third field) (pascal-type-size (fourth field))))
            (:byte-array (second field))
            (:boolean-array (second field))
            (:int16-array (* 2 (second field)))
            (:int32-array (* 4 (second field)))
            (:struct (pascal-type-size field))
            (:reserved (second field))
            (t (pascal-type-size field))))))

(defun pascal-type-size (type)
  (etypecase type
    ((eql :int8) 1)
    ((eql :uint8) 1)
    ((eql :byte) 1)
    ((eql :boolean) 1)
    ((eql :char) 1)
    ((eql :int16) 2)
    ((eql :uint16) 2)
    ((eql :int32) 4)
    ((eql :uint32) 4)
    ((eql :real) 8)
    (cons (case (car type)
            (:pascal-string (+ 1 (second type)))
            (:array (* (second type) (pascal-type-size (third type))))
            (:matrix (* (second type) (third type) (pascal-type-size (fourth type))))
            (:byte-array (second type))
            (:boolean-array (second type))
            (:int16-array (* 2 (second type)))
            (:int32-array (* 4 (second type)))
            (:struct (let ((layout (pascal-layout (second type))))
                      (reduce #'+ (mapcar #'pascal-field-size layout))))
            (:reserved (second type))
            (t (error "Unknown Pascal type descriptor ~S." type))))))

(defmacro define-pascal-record (name (&rest options) &body fields)
  (let* ((layout (mapcar (lambda (field)
                           (destructuring-bind (slot type &key (documentation nil)) field
                             (declare (ignore documentation))
                             (list :field slot type)))
                         fields))
         (slots (mapcar (lambda (field)
                          (destructuring-bind (slot type &rest rest) field
                            (declare (ignore rest))
                            (let* ((accessor (accessor-name name slot))
                                   (default (slot-default-for-type type)))
                              `(,slot :initarg ,(intern (symbol-name slot) :keyword)
                                      :accessor ,accessor
                                      :initform ,default))))
                        fields))
         (doc (getf options :documentation)))
    `(progn
       (defclass ,name ()
         ,slots
         (:documentation ,doc))
       (register-layout ',name ',layout)
       ',name)))

(defun %ensure-length (string max-length)
  (let ((length (length string)))
    (when (> length max-length)
      (error "String ~S exceeds Pascal field length ~D." string max-length))
    string))

(defun %write-int16 (value vector index)
  (setf (aref vector index) (ldb (byte 8 8) value)
        (aref vector (1+ index)) (ldb (byte 8 0) value))
  (+ index 2))

(defun %write-uint16 (value vector index)
  (%write-int16 value vector index))

(defun %write-int32 (value vector index)
  (setf (aref vector index) (ldb (byte 8 24) value)
        (aref vector (1+ index)) (ldb (byte 8 16) value)
        (aref vector (+ index 2)) (ldb (byte 8 8) value)
        (aref vector (+ index 3)) (ldb (byte 8 0) value))
  (+ index 4))

(defun %write-real (value vector index)
  (multiple-value-bind (mantissa exponent sign)
      (integer-decode-float (coerce value 'double-float))
    (let* ((sign-bit (if (minusp sign) 1 0))
           (abs-mantissa (abs mantissa))
           (biased-exponent (+ exponent 1022)))
      (unless (<= 0 biased-exponent 2046)
        (error "Real value out of IEEE double range: ~A" value))
      (let ((bits (+ (* sign-bit (expt 2 63))
                     (* biased-exponent (expt 2 52))
                     (ash (1- abs-mantissa) (- 52))))))
        (dotimes (i 8)
          (setf (aref vector (+ index i)) (ldb (byte 8 (- 56 (* i 8))) bits))))))
  (+ index 8))

(defun %read-int16 (vector index)
  (values (logior (ash (aref vector index) 8)
                  (aref vector (1+ index)))
          (+ index 2)))

(defun %read-signed-int16 (vector index)
  (multiple-value-bind (value next) (%read-int16 vector index)
    (values (if (logbitp 15 value)
                (- value (expt 2 16))
                value)
            next)))

(defun %read-int32 (vector index)
  (values (logior (ash (aref vector index) 24)
                  (ash (aref vector (1+ index)) 16)
                  (ash (aref vector (+ index 2)) 8)
                  (aref vector (+ index 3)))
          (+ index 4)))

(defun %read-real (vector index)
  (let ((bits 0))
    (dotimes (i 8)
      (setf bits (logior (ash bits 8) (aref vector (+ index i)))))
    (let* ((sign (if (zerop (ldb (byte 1 63) bits)) 1 -1))
           (exponent (ldb (byte 11 52) bits))
           (fraction (ldb (byte 52 0) bits)))
      (cond
        ((zerop exponent)
         (values (* sign (ldexp fraction (- 1074))) (+ index 8)))
        ((= exponent #x7ff)
         (values (* sign double-float-positive-infinity) (+ index 8)))
        (t
         (let* ((mantissa (+ (expt 2 52) fraction))
                (value (* sign (ldexp mantissa (- exponent 1075)))))
           (values (coerce value 'double-float) (+ index 8)))))))

(defun serialize-field (type value vector index)
  (etypecase type
    ((eql :int8)
     (setf (aref vector index) (ldb (byte 8 0) value))
     (1+ index))
    ((eql :uint8)
     (setf (aref vector index) value)
     (1+ index))
    ((eql :byte)
     (setf (aref vector index) value)
     (1+ index))
    ((eql :boolean)
     (setf (aref vector index) (if value 1 0))
     (1+ index))
    ((eql :char)
     (setf (aref vector index) (char-code value))
     (1+ index))
    ((eql :int16)
     (%write-int16 value vector index))
    ((eql :uint16)
     (%write-uint16 value vector index))
    ((eql :int32)
     (%write-int32 value vector index))
    ((eql :uint32)
     (%write-int32 value vector index))
    ((eql :real)
     (%write-real value vector index))
    (cons
     (case (car type)
       (:pascal-string
        (let* ((max-length (second type))
               (string (%ensure-length value max-length))
               (length (length string)))
          (setf (aref vector index) length)
          (dotimes (i max-length)
            (setf (aref vector (+ index 1 i))
                  (if (< i length) (char-code (char string i)) 0)))
          (+ index 1 max-length)))
       (:array
        (let ((count (second type))
              (element-type (third type)))
          (dotimes (i count index)
            (setf index (serialize-field element-type (elt value i) vector index)))))
       (:matrix
        (let ((rows (second type))
              (cols (third type))
              (element-type (fourth type)))
          (dotimes (row rows index)
            (let ((row-vector (aref value row)))
              (dotimes (col cols)
                (setf index (serialize-field element-type (aref row-vector col) vector index)))))))
       (:byte-array
        (let ((count (second type)))
          (dotimes (i count index)
            (setf (aref vector (+ index i)) (aref value i)))
          (+ index count)))
       (:boolean-array
        (let ((count (second type)))
          (dotimes (i count index)
            (setf (aref vector (+ index i)) (if (elt value i) 1 0)))
          (+ index count)))
       (:int16-array
        (let ((count (second type)))
          (dotimes (i count index)
            (setf index (%write-int16 (elt value i) vector index)))
          index))
       (:int32-array
        (let ((count (second type)))
          (dotimes (i count index)
            (setf index (%write-int32 (elt value i) vector index)))
          index))
       (:struct
        (let* ((name (second type))
               (layout (pascal-layout name))
               (class (ignore-errors (find-class name nil)))
               (struct-bytes (cond
                               ((and class (typep value class))
                                (serialize-record value))
                               ((listp value)
                                (serialize-struct layout value))
                               (t (error "Unsupported struct value ~S for ~S." value name)))))
          (replace vector struct-bytes :start1 index)
          (+ index (length struct-bytes))))
       (:reserved
        (let ((count (second type)))
          (replace vector value :start1 index)
          (+ index count)))
       (t (error "Unsupported Pascal type descriptor ~S." type))))))

(defun serialize-struct (layout values)
  (let* ((size (reduce #'+ (mapcar #'pascal-field-size layout)))
         (buffer (make-array size :element-type '(unsigned-byte 8)))
         (index 0))
    (dolist (field layout buffer)
      (destructuring-bind (&key field) field
        (if field
            (destructuring-bind (name type) (cdr field)
              (setf index (serialize-field type (getf values name) buffer index)))
            (let ((skip (getf field :skip)))
              (incf index skip))))))

(defun serialize-record (instance)
  (let* ((layout (pascal-layout instance))
         (size (reduce #'+ (mapcar #'pascal-field-size layout)))
         (buffer (make-array size :element-type '(unsigned-byte 8)))
         (index 0))
    (dolist (field layout buffer)
      (destructuring-bind (marker name type) field
        (declare (ignore marker))
        (setf index (serialize-field type (slot-value instance name) buffer index))))))

(defun read-pascal-string (vector index max-length)
  (let* ((length (aref vector index))
         (start (1+ index))
         (end (+ start length))
         (string (coerce (loop for i from start below end collect (code-char (aref vector i))) 'string)))
    (values string (+ index 1 max-length)))

(defun deserialize-field (type vector index)
  (etypecase type
    ((eql :int8)
     (values (if (> (aref vector index) 127)
                 (- (aref vector index) 256)
                 (aref vector index))
             (1+ index)))
    ((eql :uint8)
     (values (aref vector index) (1+ index)))
    ((eql :byte)
     (values (aref vector index) (1+ index)))
    ((eql :boolean)
     (values (not (zerop (aref vector index))) (1+ index)))
    ((eql :char)
     (values (code-char (aref vector index)) (1+ index)))
    ((eql :int16)
     (%read-signed-int16 vector index))
    ((eql :uint16)
     (%read-int16 vector index))
    ((eql :int32)
     (%read-int32 vector index))
    ((eql :uint32)
     (%read-int32 vector index))
    ((eql :real)
     (%read-real vector index))
    (cons
     (case (car type)
       (:pascal-string
        (read-pascal-string vector index (second type)))
       (:array
        (let ((count (second type))
              (element-type (third type))
              (results (make-array (second type))))
          (dotimes (i count)
            (multiple-value-bind (element next-index)
                (deserialize-field element-type vector index)
              (setf index next-index)
              (setf (aref results i) element)))
          (values results index)))
       (:matrix
        (let ((rows (second type))
              (cols (third type))
              (element-type (fourth type))
              (matrix (make-array rows)))
          (dotimes (row rows)
            (setf (aref matrix row) (make-array cols))
            (dotimes (col cols)
              (multiple-value-bind (value next-index)
                  (deserialize-field element-type vector index)
                (setf index next-index)
                (setf (aref (aref matrix row) col) value))))
          (values matrix index)))
       (:byte-array
        (let ((count (second type))
              (bytes (make-array (second type) :element-type '(unsigned-byte 8))))
          (replace bytes vector :start2 index :end2 (+ index count))
          (values bytes (+ index count))))
       (:boolean-array
        (let ((count (second type))
              (values (make-array (second type))))
          (dotimes (i count)
            (setf (aref values i) (not (zerop (aref vector (+ index i))))))
          (values values (+ index count))))
       (:int16-array
        (let ((count (second type))
              (values (make-array (second type))))
          (dotimes (i count)
            (multiple-value-bind (element next-index)
                (%read-signed-int16 vector index)
              (setf index next-index)
              (setf (aref values i) element)))
          (values values index)))
       (:int32-array
        (let ((count (second type))
              (values (make-array (second type))))
          (dotimes (i count)
            (multiple-value-bind (element next-index)
                (%read-int32 vector index)
              (setf index next-index)
              (setf (aref values i) element)))
          (values values index)))
       (:struct
        (let* ((name (second type))
               (layout (pascal-layout name))
               (size (reduce #'+ (mapcar #'pascal-field-size layout)))
               (slice (subseq vector index (+ index size)))
               (class (ignore-errors (find-class name nil)))
               (value (if class
                          (deserialize-record name slice)
                          (deserialize-struct layout slice 0))))
          (values value (+ index size))))
       (:reserved
        (let ((count (second type))
              (bytes (subseq vector index (+ index count))))
          (values bytes (+ index count))))
       (t (error "Unsupported Pascal type descriptor ~S." type))))))

(defun deserialize-struct (layout vector index)
  (let ((result '()))
    (dolist (field layout (nreverse result))
      (destructuring-bind (&key field skip) field
        (cond
          (field
           (destructuring-bind (name type) (cdr field)
             (multiple-value-bind (value next-index)
                 (deserialize-field type vector index)
               (setf index next-index)
               (push name result)
               (push value result))))
          (skip
           (incf index skip)))))
    result))

(defun deserialize-record (class octets)
  (let* ((layout (pascal-layout class))
         (instance (make-instance class))
         (index 0))
    (dolist (field layout instance)
      (destructuring-bind (marker name type) field
        (declare (ignore marker))
        (multiple-value-setq (value index) (deserialize-field type octets index))
        (setf (slot-value instance name) value)))))

(defmacro with-pascal-string ((var string) &body body)
  `(ccl:%stack-block ((,var 256))
     (let* ((str ,string)
            (length (min (length str) 255)))
       (setf (ccl:%get-unsigned-byte ,var 0) length)
       (dotimes (i length)
         (setf (ccl:%get-unsigned-byte ,var (1+ i)) (char-code (char str i))))
       (loop for i from (1+ length) below 256 do
             (setf (ccl:%get-unsigned-byte ,var i) 0))
       ,@body)))

(defmacro with-legacy-file ((refnum path &key (permission :fsRdWrPerm)) &body body)
  `(let ((perm ,permission))
     (declare (ignore perm))
     (with-pascal-string (path-str ,path)
       (ccl:rlet ((ref :signed-short))
         (let ((err (#_FSOpen path-str 0 ref)))
           (when (not (zerop err))
             (error "Unable to open legacy file ~A (~D)." ,path err))
           (let ((,refnum (ccl:rref ref :signed-short)))
             (unwind-protect (progn ,@body)
               (#_FSClose ,refnum))))))))

(defmacro with-resource-file ((refnum path &key (permission :fsRdWrPerm)) &body body)
  `(let ((perm ,permission))
     (with-pascal-string (path-str ,path)
       (let* ((previous (#_CurResFile))
              (resource-ref (#_OpenRFPerm path-str 0 (permission-code perm))))
         (when (= resource-ref -1)
           (error "Unable to open resource file ~A." ,path))
         (unwind-protect
              (progn
                (#_UseResFile resource-ref)
                (let ((,refnum resource-ref))
                  ,@body))
           (#_CloseResFile resource-ref)
           (#_UseResFile previous))))))

(defun fs-read-bytes (refnum count)
  (let ((buffer (make-array count :element-type '(unsigned-byte 8))))
    (ccl:with-pointer-to-vector-data (ptr buffer)
      (ccl:rlet ((amount :unsigned-long))
        (setf (ccl:rref amount :unsigned-long) count)
        (let ((err (#_FSRead refnum amount ptr)))
          (when (and (not (zerop err)) (not (= err +eof-err+)))
            (error "FSRead failed (~D)." err))
          (let ((actual (ccl:rref amount :unsigned-long)))
            (if (< actual count)
                (subseq buffer 0 actual)
                buffer))))))

(defun fs-write-bytes (refnum bytes)
  (ccl:with-pointer-to-vector-data (ptr bytes)
    (ccl:rlet ((amount :unsigned-long))
      (setf (ccl:rref amount :unsigned-long) (length bytes))
      (let ((err (#_FSWrite refnum amount ptr)))
        (when (not (zerop err))
          (error "FSWrite failed (~D)." err))))))

(defun record-byte-size (class)
  (reduce #'+ (mapcar #'pascal-field-size (pascal-layout class))))

(defun %pointer-to-vector (ptr size)
  (let ((bytes (make-array size :element-type '(unsigned-byte 8))))
    (dotimes (i size bytes)
      (setf (aref bytes i) (ccl:%get-unsigned-byte ptr i)))))

(defun %vector-to-pointer (bytes ptr)
  (let ((size (length bytes)))
    (dotimes (i size)
      (ccl:%put-unsigned-byte ptr i (aref bytes i))))
  ptr)

(defun read-resource-record (path type id class)
  (with-resource-file (ref path)
    (declare (ignore ref))
    (let ((handle (#_Get1Resource type id)))
      (when (or (ccl:%null-ptr-p handle))
        (error "Resource ~A/~D not found in ~A." type id path))
      (#_HLock handle)
      (unwind-protect
           (ccl:with-dereferenced-handle (ptr handle)
             (let* ((size (#_GetHandleSize handle))
                    (expected (record-byte-size class)))
               (unless (= size expected)
                 (error "Resource ~A/~D in ~A expected ~D bytes, found ~D."
                        type id path expected size))
               (let ((bytes (%pointer-to-vector ptr size)))
                 (deserialize-record class bytes))))
        (#_HUnlock handle)
        (#_ReleaseResource handle))))

(defun write-resource-record (path type id record)
  (with-resource-file (ref path)
    (declare (ignore ref))
    (let ((handle (#_Get1Resource type id)))
      (when (or (ccl:%null-ptr-p handle))
        (error "Resource ~A/~D not found in ~A." type id path))
      (let* ((bytes (serialize-record record))
             (expected (length bytes)))
        (#_HLock handle)
        (unwind-protect
             (ccl:with-dereferenced-handle (ptr handle)
               (let ((size (#_GetHandleSize handle)))
                 (unless (= size expected)
                   (error "Resource size mismatch for ~A/~D in ~A (expected ~D bytes, have ~D)."
                          type id path expected size))
                 (%vector-to-pointer bytes ptr)
                 (#_ChangedResource handle)
                 (#_WriteResource handle)))
          (#_HUnlock handle)
          (#_ReleaseResource handle))))))

(defun read-legacy-records (path class &key count)
  (with-legacy-file (ref path :permission :fsRdPerm)
    (let* ((size (record-byte-size class))
           (records '()))
      (ccl:rlet ((eof :unsigned-long))
        (let ((err (#_GetEOF ref eof)))
          (when (not (zerop err))
            (error "GetEOF failed (~D) for ~A." err path))
          (let ((total (ccl:rref eof :unsigned-long)))
            (when (and (> total 0) (not (zerop (mod total size))))
              (error "File ~A size ~D is not a multiple of record size ~D." path total size))))
        (ccl:rlet ((pos :unsigned-long))
          (setf (ccl:rref pos :unsigned-long) 0)
          (let ((set-pos (#_SetFPos ref +fs-from-start+ pos)))
            (when (not (zerop set-pos))
              (error "Unable to seek to start of ~A (~D)." path set-pos)))))
      (if count
          (dotimes (i count (nreverse records))
            (declare (ignore i))
            (let ((chunk (fs-read-bytes ref size)))
              (when (/= (length chunk) size)
                (return (nreverse records)))
              (push (deserialize-record class chunk) records)))
          (loop
            for chunk = (fs-read-bytes ref size)
            while (= (length chunk) size)
            do (push (deserialize-record class chunk) records)
            finally (return (nreverse records)))))))

(defun write-legacy-record (path class record &key (offset 0))
  (with-legacy-file (ref path)
    (let* ((bytes (serialize-record record))
           (expected (record-byte-size class)))
      (unless (= (length bytes) expected)
        (error "Serialized record for ~A produced ~D bytes; expected ~D."
               class (length bytes) expected))
      (ccl:rlet ((pos :unsigned-long))
        (setf (ccl:rref pos :unsigned-long) offset)
        (let ((err (#_SetFPos ref +fs-from-start+ pos)))
          (when (not (zerop err))
            (error "SetFPos failed (~D)." err))))
      (fs-write-bytes ref bytes)
      record))

(defun warm-legacy-caches (shared-path)
  (clrhash *legacy-caches*)
  (let* ((base (if (pathnamep shared-path) shared-path (pathname shared-path)))
         (system (read-resource-record (merge-pathnames "System Prefs" base) :|Sprf| 0 'system-record))
         (menus-path (merge-pathnames "Menus" base))
         (message-path (merge-pathnames "Message" base)))
    (setf (gethash :system *legacy-caches*) system)
    (setf (gethash :menus *legacy-caches*)
          (list :node (read-resource-record menus-path :|MenU| 0 'node-menu-record)
                :transfer (read-resource-record menus-path :|MenU| 1 'transfer-menu-record)))
    (setf (gethash :forum-index *legacy-caches*)
          (read-resource-record (merge-pathnames "Directories" base) :|Info| 0 'forum-index-record))
    (setf (gethash :security-levels *legacy-caches*)
          (read-resource-record (merge-pathnames "Security Levels" base) :|Lvls| 0 'security-level-table))
    (setf (gethash :gfile-sections *legacy-caches*)
          (read-resource-record (merge-pathnames "GFiles" base) :|Gfil| 0 'gfile-section-table))
    (setf (gethash :mailer *legacy-caches*)
          (read-resource-record (merge-pathnames "Mailer Prefs" base) :|Info| 0 'mailer-record))
    (setf (gethash :new-user-template *legacy-caches*)
          (read-resource-record (merge-pathnames "New User" base) :|NEWu| 0 'new-user-record))
    (setf (gethash :message-forums *legacy-caches*)
          (read-resource-record message-path :|MFor| 0 'message-forum-table))
    (setf (gethash :feedback *legacy-caches*)
          (read-resource-record message-path :|MFor| 1 'feedback-record))
    (let* ((forum-count (min +max-message-forums+
                             (system-record-message-forum-count system)))
           (conference-records '()))
      (dotimes (i forum-count)
        (handler-case
            (push (read-resource-record message-path :|Conf| i 'conference-table) conference-records)
          (error () (return))))
      (setf (gethash :conference-tables *legacy-caches*) (nreverse conference-records)))
    (setf (gethash :users *legacy-caches*)
          (read-legacy-records (merge-pathnames "Users" base) 'user-record))
    (setf (gethash :action-words *legacy-caches*)
          (read-legacy-records (merge-pathnames "Action Words" base) 'action-word-record))
    *legacy-caches*))

;;; Basic structure definitions

(register-layout 'rect
                 '((:field top :int16)
                   (:field left :int16)
                   (:field bottom :int16)
                   (:field right :int16)))

(register-layout 'date-time-rec
                 '((:field second :int16)
                   (:field minute :int16)
                   (:field hour :int16)
                   (:field day :int16)
                   (:field month :int16)
                   (:field year :int16)
                   (:field day-of-week :int16)))

;;; Record definitions

(define-pascal-record user-record
    ()
  (user-num :int16)
  (sl :int16)
  (dsl :int16)
  (user-name (:pascal-string 31))
  (real-name (:pascal-string 21))
  (alias (:pascal-string 31))
  (phone (:pascal-string 12))
  (password (:pascal-string 9))
  (data-phone (:pascal-string 12))
  (company (:pascal-string 30))
  (street (:pascal-string 30))
  (city (:pascal-string 30))
  (state (:pascal-string 6))
  (zip (:pascal-string 10))
  (country (:pascal-string 10))
  (computer-type (:pascal-string 23))
  (sysop-note (:pascal-string 41))
  (misc-field-1 (:pascal-string 60))
  (misc-field-2 (:pascal-string 60))
  (misc-field-3 (:pascal-string 60))
  (last-baud (:pascal-string 19))
  (access-letters (:boolean-array 26))
  (cant-post :boolean)
  (cant-chat :boolean)
  (ud-ratio-on :boolean)
  (pc-ratio-on :boolean)
  (cant-post-anon :boolean)
  (cant-send-email :boolean)
  (cant-change-auto-msg :boolean)
  (cant-list-user :boolean)
  (cant-add-to-bbs-list :boolean)
  (cant-see-ul-info :boolean)
  (cant-read-anon :boolean)
  (restrict-hours :boolean)
  (cant-send-pp-file :boolean)
  (cant-net-mail :boolean)
  (read-before-dl :boolean)
  (reserved-restricts (:boolean-array 4))
  (deleted-user :boolean)
  (last-on :int32)
  (first-on :int32)
  (sex :boolean)
  (birth-day :char)
  (birth-month :char)
  (birth-year :char)
  (age :byte)
  (on-today :int16)
  (total-logons :int16)
  (min-on-today :int16)
  (total-time-on :int32)
  (illegal-logons :int16)
  (messages-posted :int16)
  (messages-posted-today :int16)
  (email-sent :int16)
  (email-sent-today :int16)
  (num-uploaded :int16)
  (num-uploaded-today :int16)
  (num-downloaded :int16)
  (num-downloaded-today :int16)
  (uploaded-k :int32)
  (uploaded-k-today :int32)
  (downloaded-k :int32)
  (downloaded-k-today :int32)
  (screen-width :int16)
  (screen-height :int16)
  (terminal-type :byte)
  (color-terminal :boolean)
  (use-day-or-call :boolean)
  (time-allowed :int16)
  (calls-per-day :int16)
  (messages-per-day :int16)
  (lines-per-message :int16)
  (dl-ratio-one-to :int16)
  (post-ratio-one-to :int16)
  (dl-credits :int32)
  (co-sysop :boolean)
  (alert-on :boolean)
  (last-password-change :int32)
  (donation (:pascal-string 20))
  (last-donation (:pascal-string 20))
  (expiration-date (:pascal-string 20))
  (alternate-text :boolean)
  (start-hour :int32)
  (end-hour :int32)
  (foregrounds (:byte-array 18))
  (backgrounds (:byte-array 18))
  (intense (:boolean-array 18))
  (underlines (:boolean-array 18))
  (blinking (:boolean-array 18))
  (what-tn-scan (:boolean-array 64))
  (what-n-scan (:matrix 20 50 :boolean))
  (last-messages (:matrix 20 50 :int32))
  (last-file-scan :int32)
  (pause-screen :boolean)
  (default-protocol :byte)
  (mailbox :boolean)
  (forwarded-to (:pascal-string 45))
  (expert :boolean)
  (ntrans-after-message :boolean)
  (extended-lines :byte)
  (extended-description :boolean)
  (screen-clears :boolean)
  (notify-logon :boolean)
  (scan-at-logon :boolean)
  (allow-interruptions :boolean)
  (downloads-by-others :int32)
  (signature (:pascal-string 80))
  (columns :boolean)
  (message-compression :real)
  (transfer-compression :real)
  (bonus-time :int32)
  (auto-sense :boolean)
  (chat-ansi :boolean)
  (message-header :int16)
  (transfer-header :int16)
  (reserved (:byte-array 50)))

(define-pascal-record new-user-record
    ()
  (handle :boolean)
  (gender :boolean)
  (require-real-name :boolean)
  (require-birth-day :boolean)
  (require-city :boolean)
  (require-country :boolean)
  (require-data-phone :boolean)
  (require-company :boolean)
  (require-street :boolean)
  (require-computer :boolean)
  (sysop-flags (:boolean-array 3))
  (sysop-text (:array 3 (:pascal-string 60)))
  (no-voice-feedback :boolean)
  (quick-scan-back :int16)
  (no-auto-capital :boolean)
  (require-voice-phone :boolean)
  (reserved (:byte-array 997)))

(define-pascal-record gfile-section
    ()
  (name (:pascal-string 50))
  (minimum-security :int16)
  (minimum-age :int16)
  (restriction :char)
  (reserved (:byte-array 13)))

(define-pascal-record gfile-section-table
    ()
  (count :int16)
  (sections (:array 99 (:struct gfile-section))))

(define-pascal-record security-level-entry
    ()
  (class-name (:pascal-string 30))
  (use-day-or-call :boolean)
  (read-anonymous :boolean)
  (time-allowed :int16)
  (messages-per-day :int16)
  (download-ratio :int16)
  (post-ratio :int16)
  (calls-per-day :int16)
  (lines-per-message :int16)
  (may-post :boolean)
  (may-add-bbs :boolean)
  (may-view-uploader :boolean)
  (enforce-upload-download :boolean)
  (may-chat :boolean)
  (may-email :boolean)
  (may-list-users :boolean)
  (may-change-auto-message :boolean)
  (may-post-anonymously :boolean)
  (enforce-post-call :boolean)
  (transfer-level :int16)
  (restrictions (:boolean-array 26))
  (forum-flags (:boolean-array 10))
  (node-flags (:boolean-array +max-nodes+))
  (active :boolean)
  (transfer-compression :real)
  (message-compression :real)
  (must-read :boolean)
  (person-to-person-files :boolean)
  (enable-hours :boolean)
  (alternate-text :boolean)
  (cant-net-mail :boolean)
  (reserved (:byte-array 23)))

(define-pascal-record security-level-table
    ()
  (levels (:array 255 (:struct security-level-entry))))

(define-pascal-record feedback-record
    ()
  (count :int16)
  (user-numbers (:int16-array 20))
  (specialities (:array 20 (:pascal-string 40))))

(define-pascal-record forum-record
    ()
  (name (:pascal-string 41))
  (conference-count :uint8)
  (minimum-security :int16)
  (minimum-age :int16)
  (access-letter :char)
  (moderators (:int16-array 3))
  (reserved (:byte-array 25)))

(define-pascal-record conference-record
    ()
  (name (:pascal-string 41))
  (read-security :int16)
  (post-security :int16)
  (max-messages :int16)
  (anonymous-id :int16)
  (minimum-age :int16)
  (access-letter :char)
  (threading :boolean)
  (conference-type :int8)
  (use-real-names :boolean)
  (show-city :boolean)
  (allow-file-attachments :boolean)
  (download-cost :real)
  (echo-name (:pascal-string 255))
  (moderators (:int16-array 3))
  (reset-new-users :boolean)
  (reserved (:byte-array 25)))

(define-pascal-record action-word-record
    ()
  (action-word (:pascal-string 14))
  (target-user (:pascal-string 255))
  (other-users (:pascal-string 255))
  (initiating-user (:pascal-string 255))
  (unspecified (:pascal-string 255)))

(define-pascal-record address-book-record
    ()
  (entries (:array 40 (:pascal-string 45))))

(define-pascal-record mailer-record
    ()
  (application (:pascal-string 255))
  (generic-path (:pascal-string 255))
  (mailer-aware :boolean)
  (sub-launch-mailer :int8)
  (event-path (:pascal-string 255))
  (mailer-node :int16)
  (allow-crash-mail :boolean)
  (import-speed :int16)
  (internet-mail-mode :int16)
  (fido-address (:pascal-string 25))
  (use-real-names :boolean)
  (crash-mail-path (:pascal-string 255))
  (use-emsi :boolean)
  (hwt-node-number (:pascal-string 63))
  (hwt-password (:pascal-string 63))
  (hwt-origin-line (:pascal-string 255))
  (hwt-ip-address :int32)
  (reserved (:byte-array 348)))

(define-pascal-record forum-index-record
    ()
  (forum-count :int16)
  (names (:array 65 (:pascal-string 31)))
  (minimum-security (:int16-array 65))
  (restrictions (:array 65 :char))
  (directory-count (:int16-array 65))
  (age-requirements (:int16-array 65))
  (operators (:matrix 65 3 :int16))
  (last-upload (:matrix 65 64 :int32))
  (reserved (:byte-array 1000)))

(define-pascal-record message-forum-table
    ()
  (forums (:array +max-message-forums+ (:struct forum-record))))

(define-pascal-record conference-table
    ()
  (conferences (:array +max-conferences-per-forum+ (:struct conference-record))))

(define-pascal-record node-menu-record
    ()
  (names (:array 50 (:pascal-string 40)))
  (enabled (:boolean-array 50))
  (primary-security (:int16-array 50))
  (secondary-security (:int16-array 50))
  (tertiary-security (:int16-array 50))
  (options (:matrix 50 10 :boolean))
  (reserved (:byte-array 100)))

(define-pascal-record transfer-menu-record
    ()
  (names (:array 50 (:pascal-string 40)))
  (enabled (:boolean-array 50))
  (primary-security (:int16-array 50))
  (secondary-security (:int16-array 50))
  (tertiary-security (:int16-array 50))
  (options (:matrix 50 10 :boolean))
  (reserved (:byte-array 100)))

(define-pascal-record system-record
    ()
  (bbs-name (:pascal-string 40))
  (override-password (:pascal-string 9))
  (new-user-password (:pascal-string 9))
  (total-calls :int32)
  (user-count :int16)
  (operator-start-hour :int32)
  (operator-end-hour :int32)
  (closed :boolean)
  (node-count :int16)
  (unused-mouse-ticks :int16)
  (last-maintenance (:struct date-time-rec))
  (last-upload :int32)
  (last-download :int32)
  (last-post :int32)
  (last-email :int32)
  (anonymous-user-number :int16)
  (anonymous-automatic :boolean)
  (serial-number (:pascal-string 40))
  (gfiles-path (:pascal-string 255))
  (messages-path (:pascal-string 255))
  (data-path (:pascal-string 255))
  (mail-attachments-enabled :boolean)
  (mail-download-cost :real)
  (free-mail-download :boolean)
  (message-forum-count :int16)
  (network-node-count :uint8)
  (bbs-names (:array (+ +max-nodes-minus-one+ 1) (:pascal-string 40)))
  (bbs-numbers (:array (+ +max-nodes-minus-one+ 1) (:pascal-string 40)))
  (bbs-dial-it (:boolean-array (+ +max-nodes-minus-one+ 1)))
  (bbs-dialed (:boolean-array (+ +max-nodes-minus-one+ 1)))
  (window-nodes-standard (:array +max-nodes+ (:struct rect)))
  (window-nodes-user (:array +max-nodes+ (:struct rect)))
  (window-open (:boolean-array (+ +max-nodes+ 1)))
  (status-window (:struct rect))
  (users-window (:struct rect))
  (users-window-open :boolean)
  (restriction-names (:array +max-restrictions+ (:pascal-string 20)))
  (calls-today (:int16-array +max-nodes+))
  (messages-posted-today (:int16-array +max-nodes+))
  (email-sent-today (:int16-array +max-nodes+))
  (uploads-today (:int16-array +max-nodes+))
  (kilobytes-uploaded (:int32-array +max-nodes+))
  (minutes-today (:int16-array +max-nodes+))
  (downloads-today (:int16-array +max-nodes+))
  (kilobytes-downloaded (:int32-array +max-nodes+))
  (failed-uploads (:int16-array +max-nodes+))
  (failed-downloads (:int16-array +max-nodes+))
  (last-user (:pascal-string 31))
  (unused-1 :int32)
  (two-way-chat :boolean)
  (use-transfer-window :boolean)
  (nine-point-font :boolean)
  (formatted-phone-number :boolean)
  (closed-transfers :boolean)
  (protocol-time-slice :int16)
  (black-on-white :int16)
  (mail-delete-days :int16)
  (two-color-chat :boolean)
  (allow-pauses :boolean)
  (download-credits :int32)
  (log-days :uint8)
  (log-detail :uint8)
  (real-serial-number (:pascal-string 80))
  (start-date :int32)
  (screen-saver (:byte-array 2))
  (log-by-totals :boolean)
  (end-string (:pascal-string 80))
  (use-bold :boolean)
  (version :int16)
  (quoter-enabled :boolean)
  (screen-saver-lock :boolean)
  (disable-ansi-detect :boolean)
  (disable-transfer-path-checking :boolean)
  (quote-header (:pascal-string 255))
  (quote-header-anonymous (:pascal-string 255))
  (use-quote-header :boolean)
  (quote-header-options :int16)
  (foreground-colors (:byte-array 7))
  (background-colors (:byte-array 7))
  (intense-colors (:boolean-array 7))
  (underline-colors (:boolean-array 7))
  (blinking-colors (:boolean-array 7))
  (debug-telnet :boolean)
  (debug-telnet-to-file :boolean)
  (reserved (:byte-array 470)))

;;; Additional record definitions for system and supporting data would follow.

