(in-package :hermes.ui)

(defparameter *ansi-base-colors*
  '((0 0 0) (205 0 0) (0 205 0) (205 205 0)
    (0 0 238) (205 0 205) (0 205 205) (229 229 229)
    (127 127 127) (255 0 0) (0 255 0) (255 255 0)
    (92 92 255) (255 0 255) (0 255 255) (255 255 255))
  "Default 16-color ANSI palette expressed as 0-255 RGB triples.")

(defun %normalize-component (value)
  (cond
    ((typep value 'integer)
     (cond ((< value 0) 0)
           ((<= value 255) (* value 257))
           ((<= value 65535) value)
           (t 65535)))
    ((typep value 'float)
     (let ((scaled (round (* (max 0.0 (min value 1.0)) 65535))))
       (max 0 (min scaled 65535))))
    (t 0)))

(defun %normalize-color (color)
  (let ((vector (make-array 3 :element-type 'fixnum)))
    (etypecase color
      (list
       (setf (aref vector 0) (%normalize-component (first color))
             (aref vector 1) (%normalize-component (second color))
             (aref vector 2) (%normalize-component (third color))))
      (vector
       (setf (aref vector 0) (%normalize-component (aref color 0))
             (aref vector 1) (%normalize-component (aref color 1))
             (aref vector 2) (%normalize-component (aref color 2)))))
    vector))

(defun %make-default-palette ()
  (let ((palette (make-array 16)))
    (dotimes (i 16 palette)
      (setf (aref palette i) (%normalize-color (nth i *ansi-base-colors*))))))

(defstruct (ansi-cell-attributes
             (:constructor make-ansi-cell-attributes (foreground background &key bold underline inverse blink)))
  (foreground 7 :type integer)
  (background 0 :type integer)
  (bold nil :type boolean)
  (underline nil :type boolean)
  (inverse nil :type boolean)
  (blink nil :type boolean))

(defun copy-ansi-cell-attributes (attributes)
  (and attributes
       (make-ansi-cell-attributes (ansi-cell-attributes-foreground attributes)
                                  (ansi-cell-attributes-background attributes)
                                  :bold (ansi-cell-attributes-bold attributes)
                                  :underline (ansi-cell-attributes-underline attributes)
                                  :inverse (ansi-cell-attributes-inverse attributes)
                                  :blink (ansi-cell-attributes-blink attributes))))

(defclass ansi-terminal-view (ccl:view)
  ((rows :initarg :rows :accessor ansi-terminal-view-rows :initform 24)
   (columns :initarg :columns :accessor ansi-terminal-view-columns :initform 80)
   (buffer :accessor ansi-terminal-view-buffer)
   (attribute-buffer :accessor ansi-terminal-view-attribute-buffer)
   (palette :accessor ansi-terminal-view-palette)
   (font-name :initarg :font-name :accessor ansi-terminal-view-font-name :initform "Monaco")
   (font-size :initarg :font-size :accessor ansi-terminal-view-font-size :initform 9)
   (font-id :accessor ansi-terminal-view-font-id :initform nil)
   (font-ascent :accessor ansi-terminal-view-font-ascent :initform 9)
   (font-descent :accessor ansi-terminal-view-font-descent :initform 2)
   (font-leading :accessor ansi-terminal-view-font-leading :initform 0)
   (cell-width :accessor ansi-terminal-view-cell-width :initform 6)
   (cell-height :accessor ansi-terminal-view-cell-height :initform 11)
   (baseline-offset :accessor ansi-terminal-view-baseline-offset :initform 9)
   (mouse-handler :initarg :mouse-handler :accessor ansi-terminal-view-mouse-handler :initform nil)
   (selection-handler :initarg :selection-handler :accessor ansi-terminal-view-selection-handler :initform nil)
   (resize-handler :initarg :resize-handler :accessor ansi-terminal-view-resize-handler :initform nil)
   (copy-handler :initarg :copy-handler :accessor ansi-terminal-view-copy-handler :initform nil)
   (selection-start :accessor ansi-terminal-view-selection-start :initform nil)
   (selection-end :accessor ansi-terminal-view-selection-end :initform nil)
   (dirty-lines :accessor ansi-terminal-view-dirty-lines :initform nil))
  (:documentation "Custom ANSI terminal view backed by QuickDraw for the Hermes UI."))

(defun make-ansi-terminal-view (&rest initargs)
  (apply #'make-instance 'ansi-terminal-view initargs))

(defun %make-char-buffer (rows columns)
  (make-array (list rows columns) :element-type 'character :initial-element #\Space))

(defun %make-attribute-buffer (rows columns)
  (let ((buffer (make-array (list rows columns))))
    (dotimes (row rows buffer)
      (dotimes (col columns)
        (setf (aref buffer row col) (make-ansi-cell-attributes 7 0))))))

(defun %mark-all-dirty (view)
  (setf (ansi-terminal-view-dirty-lines view)
        (loop for row below (ansi-terminal-view-rows view) collect row)))

(defun %set-view-size (view width height)
  (cond
    ((and (fboundp 'ccl:set-view-size) width height)
     (funcall (symbol-function 'ccl:set-view-size) view width height))
    ((and width height)
     (setf (ccl:view-size view) (ccl:make-point width height))))
  view)

(defun %update-view-size (view)
  (let ((width (* (ansi-terminal-view-columns view) (ansi-terminal-view-cell-width view)))
        (height (* (ansi-terminal-view-rows view) (ansi-terminal-view-cell-height view))))
    (%set-view-size view width height)))

(defun %configure-font (view font-name font-size)
  (ccl:with-focused-view view
    (ccl:rlet ((font-id :integer))
      (ccl:with-pstrs ((p font-name))
        (when (not (zerop (#_GetFNum p font-id)))
          (error "Unknown font ~A" font-name))
        (let ((id (ccl:rref font-id :integer)))
          (#_TextFont id)
          (#_TextSize font-size)
          (#_TextFace 0)
          (setf (ansi-terminal-view-font-id view) id))))
    (ccl:rlet ((info :FontInfo))
      (#_GetFontInfo info)
      (let* ((ascent (ccl:rref info :FontInfo.ascent))
             (descent (ccl:rref info :FontInfo.descent))
             (leading (ccl:rref info :FontInfo.leading))
             (cell-width (max 1 (#_CharWidth (char-code #\W))))
             (cell-height (+ ascent descent leading)))
        (setf (ansi-terminal-view-font-ascent view) ascent
              (ansi-terminal-view-font-descent view) descent
              (ansi-terminal-view-font-leading view) leading
              (ansi-terminal-view-cell-width view) cell-width
              (ansi-terminal-view-cell-height view) (max cell-height 1)
              (ansi-terminal-view-baseline-offset view) (+ ascent (max 0 (- leading 1)))))))
  (%update-view-size view))

(defun set-terminal-font (view font-name font-size)
  "Change the QuickDraw font used for VIEW and recompute metrics."
  (setf (ansi-terminal-view-font-name view) font-name
        (ansi-terminal-view-font-size view) font-size)
  (%configure-font view font-name font-size)
  (%mark-all-dirty view)
  view)

(defmethod initialize-instance :after ((view ansi-terminal-view) &rest initargs)
  (declare (ignore initargs))
  (setf (ansi-terminal-view-palette view) (%make-default-palette))
  (setf (ansi-terminal-view-buffer view)
        (%make-char-buffer (ansi-terminal-view-rows view) (ansi-terminal-view-columns view)))
  (setf (ansi-terminal-view-attribute-buffer view)
        (%make-attribute-buffer (ansi-terminal-view-rows view) (ansi-terminal-view-columns view)))
  (%configure-font view (ansi-terminal-view-font-name view) (ansi-terminal-view-font-size view))
  (%mark-all-dirty view))

(defun %palette-entry (view index)
  (let* ((palette (ansi-terminal-view-palette view))
         (bounded (mod index 16)))
    (aref palette bounded)))

(defun set-terminal-palette (view palette &key (start 0))
  "Replace or update the ANSI palette used by VIEW."
  (let ((target (ansi-terminal-view-palette view)))
    (loop for color in palette
          for index from start
          while (< index (length target))
          do (setf (aref target index) (%normalize-color color))))
  (%mark-all-dirty view)
  view)

(defun reset-terminal (view &key (fill #\Space))
  "Clear the terminal buffer and reset selections."
  (let ((rows (ansi-terminal-view-rows view))
        (columns (ansi-terminal-view-columns view))
        (buffer (ansi-terminal-view-buffer view))
        (attributes (ansi-terminal-view-attribute-buffer view)))
    (dotimes (row rows)
      (dotimes (col columns)
        (setf (aref buffer row col) fill)
        (setf (aref attributes row col) (make-ansi-cell-attributes 7 0)))))
  (setf (ansi-terminal-view-selection-start view) nil
        (ansi-terminal-view-selection-end view) nil)
  (%mark-all-dirty view)
  view)

(defun %clamp (value minimum maximum)
  (max minimum (min maximum value)))

(defun %effective-foreground (attributes)
  (let ((foreground (ansi-cell-attributes-foreground attributes)))
    (if (and (ansi-cell-attributes-bold attributes)
             (< foreground 8))
        (min 15 (+ foreground 8))
        foreground)))

(defun %cell-selected-p (view row column)
  (let ((start (ansi-terminal-view-selection-start view))
        (end (ansi-terminal-view-selection-end view)))
    (when (and start end)
      (destructuring-bind (start-row start-column) start
        (destructuring-bind (end-row end-column) end
          (let* ((sr (min start-row end-row))
                 (er (max start-row end-row))
                 (sc (if (= start-row sr) start-column end-column))
                 (ec (if (= end-row er) end-column start-column)))
            (cond
              ((< row sr) nil)
              ((> row er) nil)
              ((= sr er)
               (and (= row sr)
                    (<= (min sc ec) column (max sc ec))))
              ((= row sr)
               (>= column (min sc ec)))
              ((= row er)
               (<= column (max sc ec)))
              (t t))))))))

(defun %draw-cell (view row column)
  (let* ((buffer (ansi-terminal-view-buffer view))
         (attributes (ansi-terminal-view-attribute-buffer view))
         (cell-attrs (aref attributes row column))
         (selected (%cell-selected-p view row column))
         (foreground (%effective-foreground cell-attrs))
         (background (ansi-cell-attributes-background cell-attrs))
         (fg-index (if selected background foreground))
         (bg-index (if selected foreground background))
         (fg-color (%palette-entry view fg-index))
         (bg-color (%palette-entry view bg-index))
         (cell-width (ansi-terminal-view-cell-width view))
         (cell-height (ansi-terminal-view-cell-height view))
         (left (* column cell-width))
         (top (* row cell-height))
         (right (+ left cell-width))
         (bottom (+ top cell-height))
         (baseline (+ top (ansi-terminal-view-font-ascent view)))
         (char (aref buffer row column)))
    (ccl:with-focused-view view
      (ccl:rlet ((rect :Rect))
        (#_SetRect rect left top right bottom)
        (ccl:rlet ((rgb :RGBColor :red (aref bg-color 0) :green (aref bg-color 1) :blue (aref bg-color 2)))
          (#_RGBBackColor rgb))
        (#_EraseRect rect))
      (ccl:rlet ((rgb :RGBColor :red (aref fg-color 0) :green (aref fg-color 1) :blue (aref fg-color 2)))
        (#_RGBForeColor rgb))
      (#_TextFont (or (ansi-terminal-view-font-id view) 0))
      (#_TextSize (ansi-terminal-view-font-size view))
      (#_TextFace 0)
      (#_MoveTo (+ left 1) baseline)
      (#_TextMode #$srcOr)
      (#_DrawChar (char-code char))
      (when (ansi-cell-attributes-underline cell-attrs)
        (#_MoveTo left (1- bottom))
        (#_LineTo right (1- bottom))))))

(defun %invalidate-row (view row)
  (ccl:with-focused-view view
    (let* ((cell-height (ansi-terminal-view-cell-height view))
           (top (* row cell-height))
           (bottom (+ top cell-height))
           (width (* (ansi-terminal-view-columns view) (ansi-terminal-view-cell-width view))))
      (ccl:rlet ((rect :Rect))
        (#_SetRect rect 0 top width bottom)
        (#_InvalRect rect)))))

(defun %invalidate-view (view)
  (ccl:with-focused-view view
    (let ((width (* (ansi-terminal-view-columns view) (ansi-terminal-view-cell-width view)))
          (height (* (ansi-terminal-view-rows view) (ansi-terminal-view-cell-height view))))
      (ccl:rlet ((rect :Rect))
        (#_SetRect rect 0 0 width height)
        (#_InvalRect rect)))))

(defmethod ccl:view-draw-contents ((view ansi-terminal-view))
  (let ((rows (or (ansi-terminal-view-dirty-lines view)
                  (loop for row below (ansi-terminal-view-rows view) collect row))))
    (dolist (row rows)
      (dotimes (column (ansi-terminal-view-columns view))
        (%draw-cell view row column)))
    (setf (ansi-terminal-view-dirty-lines view) nil)))

(defun %ensure-bounds (view row column)
  (and (<= 0 row) (< row (ansi-terminal-view-rows view))
       (<= 0 column) (< column (ansi-terminal-view-columns view))))

(defun write-terminal-character (view character row column &key foreground background bold underline inverse blink)
  "Write CHARACTER to the terminal buffer at ROW and COLUMN with optional attributes."
  (when (%ensure-bounds view row column)
    (let* ((buffer (ansi-terminal-view-buffer view))
           (attributes (ansi-terminal-view-attribute-buffer view))
           (existing (aref attributes row column))
           (current (or (copy-ansi-cell-attributes existing)
                        (make-ansi-cell-attributes 7 0))))
      (setf (aref buffer row column) (etypecase character
                                       (character character)
                                       (integer (code-char character))
                                       (string (if (> (length character) 0)
                                                  (char character 0)
                                                  #\Space))))
      (when foreground (setf (ansi-cell-attributes-foreground current) (%clamp foreground 0 15)))
      (when background (setf (ansi-cell-attributes-background current) (%clamp background 0 15)))
      (when bold (setf (ansi-cell-attributes-bold current) bold))
      (when underline (setf (ansi-cell-attributes-underline current) underline))
      (when inverse (setf (ansi-cell-attributes-inverse current) inverse))
      (when blink (setf (ansi-cell-attributes-blink current) blink))
      (setf (aref attributes row column) current)
      (pushnew row (ansi-terminal-view-dirty-lines view) :test #'=)
      (%invalidate-row view row)))
  view)

(defun write-terminal-string (view string row column &key foreground background bold underline inverse blink)
  "Write STRING into VIEW starting at ROW and COLUMN, wrapping to subsequent rows."
  (let ((current-row row)
        (current-column column))
    (loop for ch across string do
          (cond
            ((char= ch #\Newline)
             (incf current-row)
             (setf current-column column))
            ((char= ch #\Return)
             (setf current-column column))
            (t
             (when (>= current-column (ansi-terminal-view-columns view))
               (incf current-row)
               (setf current-column 0))
             (when (>= current-row (ansi-terminal-view-rows view))
               (return))
             (write-terminal-character view ch current-row current-column
                                       :foreground foreground
                                       :background background
                                       :bold bold
                                       :underline underline
                                       :inverse inverse
                                       :blink blink)
             (incf current-column)))))
  view)

(defun terminal-buffer-contents (view &key (trim-trailing-spaces t))
  "Return the terminal buffer as a list of strings."
  (let ((rows (ansi-terminal-view-rows view))
        (columns (ansi-terminal-view-columns view))
        (buffer (ansi-terminal-view-buffer view))
        (result '()))
    (dotimes (row rows (nreverse result))
      (let ((line (make-string columns)))
        (dotimes (column columns)
          (setf (aref line column) (aref buffer row column)))
        (push (if trim-trailing-spaces
                  (string-right-trim '(#\Space) line)
                  line)
              result))))

(defun %selection-bounds (view)
  (let ((start (ansi-terminal-view-selection-start view))
        (end (ansi-terminal-view-selection-end view)))
    (when (and start end)
      (let ((sr (car start))
            (sc (cadr start))
            (er (car end))
            (ec (cadr end)))
        (values (min sr er)
                (min sc ec)
                (max sr er)
                (max sc ec)))))

(defun terminal-selection-text (view)
  "Return the currently selected text as a string or NIL when no selection is active."
  (multiple-value-bind (start-row start-column end-row end-column)
      (%selection-bounds view)
    (when start-row
      (with-output-to-string (out)
        (loop for actual-row from start-row to end-row do
          (let* ((columns (ansi-terminal-view-columns view))
                 (buffer (ansi-terminal-view-buffer view))
                 (row-start (if (= actual-row start-row) start-column 0))
                 (row-end (if (= actual-row end-row)
                              end-column
                              (1- columns))))
            (loop for column from row-start to row-end do
              (write-char (aref buffer actual-row column) out))
            (when (< actual-row end-row)
              (terpri out)))))))

(defun %set-selection (view row column &key extend)
  (let ((clamped-row (%clamp row 0 (1- (ansi-terminal-view-rows view))))
        (clamped-column (%clamp column 0 (1- (ansi-terminal-view-columns view)))))
    (if extend
        (setf (ansi-terminal-view-selection-end view) (list clamped-row clamped-column))
        (setf (ansi-terminal-view-selection-start view) (list clamped-row clamped-column)
              (ansi-terminal-view-selection-end view) (list clamped-row clamped-column))))
  (%mark-all-dirty view)
  (%invalidate-view view)
  view)

(defun %notify-selection (view)
  (when (ansi-terminal-view-selection-handler view)
    (funcall (ansi-terminal-view-selection-handler view) view (terminal-selection-text view))))

(defun %notify-copy (view text)
  (when (ansi-terminal-view-copy-handler view)
    (funcall (ansi-terminal-view-copy-handler view) view text)))

(defun %point->cell (view point)
  (let* ((cell-width (max 1 (ansi-terminal-view-cell-width view)))
         (cell-height (max 1 (ansi-terminal-view-cell-height view)))
         (column (floor (ccl:point-h point) cell-width))
         (row (floor (ccl:point-v point) cell-height)))
    (values (%clamp row 0 (1- (ansi-terminal-view-rows view)))
            (%clamp column 0 (1- (ansi-terminal-view-columns view))))))

(defmethod ccl:view-click-event-handler ((view ansi-terminal-view) where)
  (multiple-value-bind (row column) (%point->cell view where)
    (%set-selection view row column)
    (%notify-selection view)
    (when (ansi-terminal-view-mouse-handler view)
      (funcall (ansi-terminal-view-mouse-handler view) view row column where)))
  t)

(defmethod ccl:view-tracking-pointer ((view ansi-terminal-view) where)
  (multiple-value-bind (row column) (%point->cell view where)
    (%set-selection view row column :extend t)
    (%notify-selection view))
  t)

(defun %set-clipboard-text (text)
  (cond
    ((and (fboundp 'ccl:set-clipboard-string) text)
     (funcall (symbol-function 'ccl:set-clipboard-string) text))
    ((and (fboundp 'ccl::set-clipboard-string) text)
     (funcall (symbol-function 'ccl::set-clipboard-string) text))
    ((and (fboundp 'ccl:set-clipboard) text)
     (funcall (symbol-function 'ccl:set-clipboard) text))
    (t (with-hermes-log ()
         (format t "Clipboard text requested but no handler is available.~%"))))
  text)

(defmethod ccl:view-copy ((view ansi-terminal-view))
  (let ((text (terminal-selection-text view)))
    (when text
      (%set-clipboard-text text)
      (%notify-copy view text)))
  t)

(defmethod ccl:view-size-changed ((view ansi-terminal-view))
  (call-next-method)
  (let* ((size (ccl:view-size view))
         (width (ccl:point-h size))
         (height (ccl:point-v size))
         (cell-width (max 1 (ansi-terminal-view-cell-width view)))
         (cell-height (max 1 (ansi-terminal-view-cell-height view)))
         (new-columns (max 1 (floor width cell-width)))
         (new-rows (max 1 (floor height cell-height))))
    (when (or (/= new-columns (ansi-terminal-view-columns view))
              (/= new-rows (ansi-terminal-view-rows view)))
      (let ((old-buffer (ansi-terminal-view-buffer view))
            (old-attributes (ansi-terminal-view-attribute-buffer view))
            (old-rows (ansi-terminal-view-rows view))
            (old-columns (ansi-terminal-view-columns view)))
        (setf (ansi-terminal-view-rows view) new-rows
              (ansi-terminal-view-columns view) new-columns
              (ansi-terminal-view-buffer view) (%make-char-buffer new-rows new-columns)
              (ansi-terminal-view-attribute-buffer view) (%make-attribute-buffer new-rows new-columns))
        (dotimes (row (min old-rows new-rows))
          (dotimes (col (min old-columns new-columns))
            (setf (aref (ansi-terminal-view-buffer view) row col) (aref old-buffer row col))
            (setf (aref (ansi-terminal-view-attribute-buffer view) row col)
                  (copy-ansi-cell-attributes (aref old-attributes row col)))))
        (%mark-all-dirty view)
        (%notify-selection view)
        (when (ansi-terminal-view-resize-handler view)
          (funcall (ansi-terminal-view-resize-handler view) view new-rows new-columns)))))
  view)
